// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Bars map[*Bar]struct{}

	Gantts map[*Gantt]struct{}

	Lanes map[*Lane]struct{}

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback OnInitCommitInterface
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	// insertion point for Commit and Checkout signatures
	CommitBar(bar *Bar)
	CheckoutBar(bar *Bar)
	CommitGantt(gantt *Gantt)
	CheckoutGantt(gantt *Gantt)
	CommitLane(lane *Lane)
	CheckoutLane(lane *Lane)
	GetLastCommitNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Bars: make(map[*Bar]struct{}, 0),

	Gantts: make(map[*Gantt]struct{}, 0),

	Lanes: make(map[*Lane]struct{}, 0),
}

func (stage *StageStruct) Commit() {
	if stage.OnInitCommitCallback != nil {
		stage.OnInitCommitCallback.BeforeCommit(stage)
	}
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getBarOrderedStructWithNameField() []*Bar {
	// have alphabetical order generation
	barOrdered := []*Bar{}
	for bar := range stage.Bars {
		barOrdered = append(barOrdered, bar)
	}
	sort.Slice(barOrdered[:], func(i, j int) bool {
		return barOrdered[i].Name < barOrdered[j].Name
	})
	return barOrdered
}

// Stage puts bar to the model stage
func (bar *Bar) Stage() *Bar {
	Stage.Bars[bar] = __member
	return bar
}

// Unstage removes bar off the model stage
func (bar *Bar) Unstage() *Bar {
	delete(Stage.Bars, bar)
	return bar
}

// commit bar to the back repo (if it is already staged)
func (bar *Bar) Commit() *Bar {
	if _, ok := Stage.Bars[bar]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitBar(bar)
		}
	}
	return bar
}

// Checkout bar to the back repo (if it is already staged)
func (bar *Bar) Checkout() *Bar {
	if _, ok := Stage.Bars[bar]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutBar(bar)
		}
	}
	return bar
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of bar to the model stage
func (bar *Bar) StageCopy() *Bar {
	_bar := new(Bar)
	*_bar = *bar
	_bar.Stage()
	return _bar
}

// StageAndCommit appends bar to the model stage and commit to the orm repo
func (bar *Bar) StageAndCommit() *Bar {
	bar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBar(bar)
	}
	return bar
}

// DeleteStageAndCommit appends bar to the model stage and commit to the orm repo
func (bar *Bar) DeleteStageAndCommit() *Bar {
	bar.Unstage()
	DeleteORMBar(bar)
	return bar
}

// StageCopyAndCommit appends a copy of bar to the model stage and commit to the orm repo
func (bar *Bar) StageCopyAndCommit() *Bar {
	_bar := new(Bar)
	*_bar = *bar
	_bar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBar(bar)
	}
	return _bar
}

// CreateORMBar enables dynamic staging of a Bar instance
func CreateORMBar(bar *Bar) {
	bar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBar(bar)
	}
}

// DeleteORMBar enables dynamic staging of a Bar instance
func DeleteORMBar(bar *Bar) {
	bar.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMBar(bar)
	}
}

func (stage *StageStruct) getGanttOrderedStructWithNameField() []*Gantt {
	// have alphabetical order generation
	ganttOrdered := []*Gantt{}
	for gantt := range stage.Gantts {
		ganttOrdered = append(ganttOrdered, gantt)
	}
	sort.Slice(ganttOrdered[:], func(i, j int) bool {
		return ganttOrdered[i].Name < ganttOrdered[j].Name
	})
	return ganttOrdered
}

// Stage puts gantt to the model stage
func (gantt *Gantt) Stage() *Gantt {
	Stage.Gantts[gantt] = __member
	return gantt
}

// Unstage removes gantt off the model stage
func (gantt *Gantt) Unstage() *Gantt {
	delete(Stage.Gantts, gantt)
	return gantt
}

// commit gantt to the back repo (if it is already staged)
func (gantt *Gantt) Commit() *Gantt {
	if _, ok := Stage.Gantts[gantt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGantt(gantt)
		}
	}
	return gantt
}

// Checkout gantt to the back repo (if it is already staged)
func (gantt *Gantt) Checkout() *Gantt {
	if _, ok := Stage.Gantts[gantt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGantt(gantt)
		}
	}
	return gantt
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gantt to the model stage
func (gantt *Gantt) StageCopy() *Gantt {
	_gantt := new(Gantt)
	*_gantt = *gantt
	_gantt.Stage()
	return _gantt
}

// StageAndCommit appends gantt to the model stage and commit to the orm repo
func (gantt *Gantt) StageAndCommit() *Gantt {
	gantt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGantt(gantt)
	}
	return gantt
}

// DeleteStageAndCommit appends gantt to the model stage and commit to the orm repo
func (gantt *Gantt) DeleteStageAndCommit() *Gantt {
	gantt.Unstage()
	DeleteORMGantt(gantt)
	return gantt
}

// StageCopyAndCommit appends a copy of gantt to the model stage and commit to the orm repo
func (gantt *Gantt) StageCopyAndCommit() *Gantt {
	_gantt := new(Gantt)
	*_gantt = *gantt
	_gantt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGantt(gantt)
	}
	return _gantt
}

// CreateORMGantt enables dynamic staging of a Gantt instance
func CreateORMGantt(gantt *Gantt) {
	gantt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGantt(gantt)
	}
}

// DeleteORMGantt enables dynamic staging of a Gantt instance
func DeleteORMGantt(gantt *Gantt) {
	gantt.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGantt(gantt)
	}
}

func (stage *StageStruct) getLaneOrderedStructWithNameField() []*Lane {
	// have alphabetical order generation
	laneOrdered := []*Lane{}
	for lane := range stage.Lanes {
		laneOrdered = append(laneOrdered, lane)
	}
	sort.Slice(laneOrdered[:], func(i, j int) bool {
		return laneOrdered[i].Name < laneOrdered[j].Name
	})
	return laneOrdered
}

// Stage puts lane to the model stage
func (lane *Lane) Stage() *Lane {
	Stage.Lanes[lane] = __member
	return lane
}

// Unstage removes lane off the model stage
func (lane *Lane) Unstage() *Lane {
	delete(Stage.Lanes, lane)
	return lane
}

// commit lane to the back repo (if it is already staged)
func (lane *Lane) Commit() *Lane {
	if _, ok := Stage.Lanes[lane]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLane(lane)
		}
	}
	return lane
}

// Checkout lane to the back repo (if it is already staged)
func (lane *Lane) Checkout() *Lane {
	if _, ok := Stage.Lanes[lane]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLane(lane)
		}
	}
	return lane
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of lane to the model stage
func (lane *Lane) StageCopy() *Lane {
	_lane := new(Lane)
	*_lane = *lane
	_lane.Stage()
	return _lane
}

// StageAndCommit appends lane to the model stage and commit to the orm repo
func (lane *Lane) StageAndCommit() *Lane {
	lane.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLane(lane)
	}
	return lane
}

// DeleteStageAndCommit appends lane to the model stage and commit to the orm repo
func (lane *Lane) DeleteStageAndCommit() *Lane {
	lane.Unstage()
	DeleteORMLane(lane)
	return lane
}

// StageCopyAndCommit appends a copy of lane to the model stage and commit to the orm repo
func (lane *Lane) StageCopyAndCommit() *Lane {
	_lane := new(Lane)
	*_lane = *lane
	_lane.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLane(lane)
	}
	return _lane
}

// CreateORMLane enables dynamic staging of a Lane instance
func CreateORMLane(lane *Lane) {
	lane.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLane(lane)
	}
}

// DeleteORMLane enables dynamic staging of a Lane instance
func DeleteORMLane(lane *Lane) {
	lane.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMLane(lane)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMBar(Bar *Bar)
	CreateORMGantt(Gantt *Gantt)
	CreateORMLane(Lane *Lane)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMBar(Bar *Bar)
	DeleteORMGantt(Gantt *Gantt)
	DeleteORMLane(Lane *Lane)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Bars = make(map[*Bar]struct{}, 0)
	stage.Gantts = make(map[*Gantt]struct{}, 0)
	stage.Lanes = make(map[*Lane]struct{}, 0)
}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Bars = nil
	stage.Gantts = nil
	stage.Lanes = nil
}
