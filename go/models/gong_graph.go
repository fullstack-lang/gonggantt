// generated by ModelGongGraphFileTemplate
package models

func IsStaged[Type Gongstruct](stage *StageStruct, instance *Type) (ok bool) {

	switch target := any(instance).(type) {
	// insertion point for stage
	case *Arrow:
		ok = stage.IsStagedArrow(target)

	case *Bar:
		ok = stage.IsStagedBar(target)

	case *Gantt:
		ok = stage.IsStagedGantt(target)

	case *Group:
		ok = stage.IsStagedGroup(target)

	case *Lane:
		ok = stage.IsStagedLane(target)

	case *LaneUse:
		ok = stage.IsStagedLaneUse(target)

	case *Milestone:
		ok = stage.IsStagedMilestone(target)

	default:
		_ = target
	}
	return
}

// insertion point for stage per struct
	func (stage *StageStruct) IsStagedArrow(arrow *Arrow) (ok bool) {

		_, ok = stage.Arrows[arrow]
	
		return
	}

	func (stage *StageStruct) IsStagedBar(bar *Bar) (ok bool) {

		_, ok = stage.Bars[bar]
	
		return
	}

	func (stage *StageStruct) IsStagedGantt(gantt *Gantt) (ok bool) {

		_, ok = stage.Gantts[gantt]
	
		return
	}

	func (stage *StageStruct) IsStagedGroup(group *Group) (ok bool) {

		_, ok = stage.Groups[group]
	
		return
	}

	func (stage *StageStruct) IsStagedLane(lane *Lane) (ok bool) {

		_, ok = stage.Lanes[lane]
	
		return
	}

	func (stage *StageStruct) IsStagedLaneUse(laneuse *LaneUse) (ok bool) {

		_, ok = stage.LaneUses[laneuse]
	
		return
	}

	func (stage *StageStruct) IsStagedMilestone(milestone *Milestone) (ok bool) {

		_, ok = stage.Milestones[milestone]
	
		return
	}


// StageBranch stages instance and apply StageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func StageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for stage branch
	case *Arrow:
		stage.StageBranchArrow(target)

	case *Bar:
		stage.StageBranchBar(target)

	case *Gantt:
		stage.StageBranchGantt(target)

	case *Group:
		stage.StageBranchGroup(target)

	case *Lane:
		stage.StageBranchLane(target)

	case *LaneUse:
		stage.StageBranchLaneUse(target)

	case *Milestone:
		stage.StageBranchMilestone(target)

	default:
		_ = target
	}
}

// insertion point for stage branch per struct
func (stage *StageStruct) StageBranchArrow(arrow *Arrow) {

	// check if instance is already staged
	if IsStaged(stage, arrow) {
		return
	}

	arrow.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if arrow.From != nil {
		StageBranch(stage, arrow.From)
	}
	if arrow.To != nil {
		StageBranch(stage, arrow.To)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchBar(bar *Bar) {

	// check if instance is already staged
	if IsStaged(stage, bar) {
		return
	}

	bar.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchGantt(gantt *Gantt) {

	// check if instance is already staged
	if IsStaged(stage, gantt) {
		return
	}

	gantt.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _lane := range gantt.Lanes {
		StageBranch(stage, _lane)
	}
	for _, _milestone := range gantt.Milestones {
		StageBranch(stage, _milestone)
	}
	for _, _group := range gantt.Groups {
		StageBranch(stage, _group)
	}
	for _, _arrow := range gantt.Arrows {
		StageBranch(stage, _arrow)
	}

}

func (stage *StageStruct) StageBranchGroup(group *Group) {

	// check if instance is already staged
	if IsStaged(stage, group) {
		return
	}

	group.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _lane := range group.GroupLanes {
		StageBranch(stage, _lane)
	}

}

func (stage *StageStruct) StageBranchLane(lane *Lane) {

	// check if instance is already staged
	if IsStaged(stage, lane) {
		return
	}

	lane.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _bar := range lane.Bars {
		StageBranch(stage, _bar)
	}

}

func (stage *StageStruct) StageBranchLaneUse(laneuse *LaneUse) {

	// check if instance is already staged
	if IsStaged(stage, laneuse) {
		return
	}

	laneuse.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if laneuse.Lane != nil {
		StageBranch(stage, laneuse.Lane)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchMilestone(milestone *Milestone) {

	// check if instance is already staged
	if IsStaged(stage, milestone) {
		return
	}

	milestone.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _laneuse := range milestone.LanesToDisplayMilestoneUse {
		StageBranch(stage, _laneuse)
	}

}


// UnstageBranch stages instance and apply UnstageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func UnstageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for unstage branch
	case *Arrow:
		stage.UnstageBranchArrow(target)

	case *Bar:
		stage.UnstageBranchBar(target)

	case *Gantt:
		stage.UnstageBranchGantt(target)

	case *Group:
		stage.UnstageBranchGroup(target)

	case *Lane:
		stage.UnstageBranchLane(target)

	case *LaneUse:
		stage.UnstageBranchLaneUse(target)

	case *Milestone:
		stage.UnstageBranchMilestone(target)

	default:
		_ = target
	}
}

// insertion point for unstage branch per struct
func (stage *StageStruct) UnstageBranchArrow(arrow *Arrow) {

	// check if instance is already staged
	if ! IsStaged(stage, arrow) {
		return
	}

	arrow.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if arrow.From != nil {
		UnstageBranch(stage, arrow.From)
	}
	if arrow.To != nil {
		UnstageBranch(stage, arrow.To)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchBar(bar *Bar) {

	// check if instance is already staged
	if ! IsStaged(stage, bar) {
		return
	}

	bar.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchGantt(gantt *Gantt) {

	// check if instance is already staged
	if ! IsStaged(stage, gantt) {
		return
	}

	gantt.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _lane := range gantt.Lanes {
		UnstageBranch(stage, _lane)
	}
	for _, _milestone := range gantt.Milestones {
		UnstageBranch(stage, _milestone)
	}
	for _, _group := range gantt.Groups {
		UnstageBranch(stage, _group)
	}
	for _, _arrow := range gantt.Arrows {
		UnstageBranch(stage, _arrow)
	}

}

func (stage *StageStruct) UnstageBranchGroup(group *Group) {

	// check if instance is already staged
	if ! IsStaged(stage, group) {
		return
	}

	group.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _lane := range group.GroupLanes {
		UnstageBranch(stage, _lane)
	}

}

func (stage *StageStruct) UnstageBranchLane(lane *Lane) {

	// check if instance is already staged
	if ! IsStaged(stage, lane) {
		return
	}

	lane.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _bar := range lane.Bars {
		UnstageBranch(stage, _bar)
	}

}

func (stage *StageStruct) UnstageBranchLaneUse(laneuse *LaneUse) {

	// check if instance is already staged
	if ! IsStaged(stage, laneuse) {
		return
	}

	laneuse.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if laneuse.Lane != nil {
		UnstageBranch(stage, laneuse.Lane)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchMilestone(milestone *Milestone) {

	// check if instance is already staged
	if ! IsStaged(stage, milestone) {
		return
	}

	milestone.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _laneuse := range milestone.LanesToDisplayMilestoneUse {
		UnstageBranch(stage, _laneuse)
	}

}

